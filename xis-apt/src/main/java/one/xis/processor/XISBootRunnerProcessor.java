package one.xis.processor;

import com.google.auto.service.AutoService;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.Writer;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Generates one.xis.xisboot.Runner and a META-INF/MANIFEST.MF
 * when a type annotated with @one.xis.boot.XISBootApplication is present.
 */
@AutoService(Processor.class)
public class XISBootRunnerProcessor extends AbstractProcessor {

    private static final String ANN_XIS_BOOT_APPLICATION = "one.xis.boot.XISBootApplication";
    private static final String RUNNER_FQCN = "one.xis.boot.Runner";
    private static final String RUNNER_PKG = "one.xis.boot";
    private static final String RUNNER_SIMPLE = "Runner";
    private static final String INTERNAL_RUNNER_FQCN = "one.xis.boot.XISBootRunner";

    private Elements elements;
    private boolean generated;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        this.elements = processingEnv.getElementUtils();
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Set.of(ANN_XIS_BOOT_APPLICATION);
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (generated || roundEnv.processingOver()) return false;

        Optional<TypeElement> appType = findApplicationType(roundEnv);
        if (appType.isEmpty()) return false;

        try {
            generateRunner(appType.get());
            generated = true;
        } catch (IOException ex) {
            error("Generation failed: " + ex.getMessage());
        }

        return false;
    }

    private Optional<TypeElement> findApplicationType(RoundEnvironment roundEnv) {
        TypeElement ann = elements.getTypeElement(ANN_XIS_BOOT_APPLICATION);
        if (ann == null) return Optional.empty();

        Set<TypeElement> candidates = roundEnv.getElementsAnnotatedWith(ann).stream()
                .filter(e -> e instanceof TypeElement)
                .map(e -> (TypeElement) e)
                .collect(Collectors.toSet());

        return switch (candidates.size()) {
            case 0 -> Optional.empty();
            case 1 -> Optional.of(candidates.iterator().next());
            default -> {
                error("Multiple @XISBootApplication types found");
                yield Optional.empty();
            }
        };
    }

    private void generateRunner(TypeElement appType) throws IOException {
        String src = buildRunnerSource(appType.getQualifiedName().toString());
        writeJava(RUNNER_FQCN, src, appType);
    }

    private String buildRunnerSource(String appFqcn) {
        String pkg = RUNNER_PKG.isEmpty() ? "" : "package " + RUNNER_PKG + ";\n\n";
        return new StringBuilder()
                .append(pkg)
                .append("public final class ").append(RUNNER_SIMPLE).append(" {\n")
                .append("  private ").append(RUNNER_SIMPLE).append("() {}\n")
                .append("  public static void main(String[] args) {\n")
                .append("    ").append(INTERNAL_RUNNER_FQCN)
                .append(".run(").append(appFqcn).append(".class, args);\n")
                .append("  }\n")
                .append("}\n")
                .toString();
    }

    private void writeJava(String fqcn, String source, Element... originating) throws IOException {
        try {
            JavaFileObject file = processingEnv.getFiler().createSourceFile(fqcn, originating);
            try (Writer w = file.openWriter()) {
                w.write(source);
            }
        } catch (javax.annotation.processing.FilerException ignoreIfExists) {
            // already generated by a prior round
        }
    }

    private void warn(String msg) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, msg);
    }

    private void error(String msg) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg);
    }
}
