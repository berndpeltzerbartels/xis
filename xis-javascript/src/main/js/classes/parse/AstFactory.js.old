
class ASTFactory {

    constructor(tokens, functions) {
        this.tokens = tokens;
        this.functions = functions;
        this.index = 0;
    }

    createAst() {
        if (this.tokens.length === 0) {
            return new NoopAst();
        }
        return this.parse(this.tokens[0]);
    }

    nextToken() {
        return this.tokens[this.index + 1];
    }

    parse(token) {
        switch (token.type) {
            case OPEN_BRACKET:
                return this.parseBrackets();
            case IDENTIFIER:
                if (this.nextToken().type === OPEN_BRACKET) {
                    return this.parseFunctionCall();
                }
                return this.parseVariable();
            case NUMBER:
            case STRING:
            case BOOLEAN:
                return this.parseConstant();
            case OPENING_SQUARE_BRACKET:
                return this.parseArray();
            case OPERATION: 
                return this.parseOperation();
            default:
                throw new Error("Unexpected token: " + this.currentToken().type);

        }
    }

    parseBrackets() {
        this.consumeToken(OPEN_BRACKET);
        const rv = this.parse();
        this.consumeToken(CLOSE_BRACKET);
        return rv;
    }

    parseOperator() {
        const left = this.createVariable(this.consumeToken(IDENTIFIER));
        const token = this.consumeToken();
        if (!this.isOperator(token)) {
            throw new Error("Expected operator, but got: " + token.type);
        }
        const right = this.parse();
        return this.createOperator(token, left, right);
    }

    parseOperartion() {
        const operationToken = this.consumeToken(OPERATION);
        const left = this.parse(operationToken.left);
        const right = this.parse(operationToken.right);
        const operator = this.createOperator(operationToken);
        return new Operation(left, operator, right);
    }



    // Liefert einen numerischen Wert für die jeweilige Präzedenz.
    getPrecedence(tokenType) {
        // Höherer Rückgabewert = höhere Präzedenz
        switch (tokenType) {
            case MUL:
            case DIV:
            case MOD:
                return 2;
            case ADD:
            case SUB:
                return 1;
            // Weitere Operatoren wie AND, OR, Vergleichsoperatoren erhalten hier ggf. niedrigere Werte.
            case AND:
            case OR:
            case EQUAL:
            case NOT_EQUAL:
            case GREATER:
            case LESS:
            case GREATER_EQUAL:
            case LESS_EQUAL:
                return 0;
            default:
                return -1;
        }
    }


    parseArray() {
        const array = [];
        this.consumeToken(OPENING_SQUARE_BRACKET);
        while (this.currentToken().type !== CLOSING_SQUARE_BRACKET) {
            if (this.currentToken().type === COMMA) {
                this.consumeToken(COMMA);
            } else {
                break;
            }
            array.push(this.parse());
        }
        this.consumeToken(CLOSING_SQUARE_BRACKET);
        return array;
    }

    parseFunctionCall() {
        const functionName = this.consumeToken(IDENTIFIER);
        const fct = this.functions[functionName.value];
        if (fct === undefined) {
            throw new Error(`Function ${functionName.value} not found`);
        }
        this.consumeToken(OPEN_BRACKET);
        const parameters = [];
        while (this.currentToken().type !== CLOSE_BRACKET) {
            parameters.push(this.parse());
            if (this.currentToken().type === COMMA) {
                this.consumeToken(COMMA);
            }
        }
        this.consumeToken(CLOSE_BRACKET);
        return new FunctionCall(fct, parameters);
    }


    isOperator(token) {
        switch (token.type) {
            case ADD:
            case SUB:
            case MUL:
            case DIV:
            case MOD:
            case AND:
            case OR:
            case EQUAL:
            case NOT_EQUAL:
            case GREATER:
            case LESS:
            case GREATER_EQUAL:
            case LESS_EQUAL:
                return true;
            default:
                return false;
        }
    }

    isConstant(token) {
        switch (token.type) {
            case NUMBER:
            case STRING:
            case BOOLEAN:
                return true;
            default:
                return false;
        }
    }

    createVariable(token) {
        return new Variable2(token.value);
    }


    createOperator(token) {
        return new Operator(this.operatorFunction(token));
    }

    operatorFunction(token) {
        switch (token.type) {
            case ADD: return (a, b) => a + b;
            case SUB: return (a, b) => a - b;
            case MUL: return (a, b) => a * b;
            case DIV: return (a, b) => a / b;
            case MOD: return (a, b) => a % b;
            case AND: return (a, b) => a && b;
            case OR: return (a, b) => a || b;
            case EQUAL: return (a, b) => a === b;
            case NOT_EQUAL: return (a, b) => a !== b;
            case GREATER: return (a, b) => a > b;
            case LESS: return (a, b) => a < b;
            case GREATER_EQUAL: return (a, b) => a >= b;
            case LESS_EQUAL: return (a, b) => a <= b;
            default:
                throw new Error("Unknown operator: " + token.type);
        }
    }
}

class Operation {

    constructor(left, operator, right) {
        this.type = 'OPERATION';
        this.left = left;
        this.right = right;
        this.operator = operator;
    }

    evaluate(data) {
        return this.operator.binaryFunction(this.left.evaluate(data), this.right.evaluate(data));
    }
}

